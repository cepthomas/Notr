%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Notr
scope: text.notr

# version: 2

# comment: |-
#   variables seem to use underscore whereas contexts use hyphen - probably convention.

file_extensions:
  - ntr
  - notr

variables:
  atx_heading: (?:[ ]{,3}[#]{1,6}(?:[ \t]|$))  # between 0 and 3 spaces, followed 1 to 6 hashes, followed by at least one space or tab or by end of the line
  atx_heading_space: (?:(?=[ \t]+#+[ \t]*$)|[ \t]+|$) # consume spaces only if heading is not empty to ensure `atx_heading_end` can fully match closing hashes
  atx_heading_end: (?:[ \t]+(#+))?[ \t]*($\n?) # \n is optional so ## is matched as end punctuation in new document (at eof)

  html_entity: '&([a-zA-Z0-9]+|#\d+|#x\h+);'
  skip_html_tags: (?:<[^>]+>)
  escape: '\\[-`*_#+.!(){}\[\]\\>|~<]'

  backticks: |-
    (?x:
      (`{4})(?![\s`])(?:[^`]+(?=`)|(?!`{4})`+(?!`))+(`{4})(?!`)  # 4 backticks, followed by at least one non whitespace, non backtick character, followed by (less than 4 backticks, or at least one non backtick character) at least once, followed by exactly 4 backticks
    | (`{3})(?![\s`])(?:[^`]+(?=`)|(?!`{3})`+(?!`))+(`{3})(?!`)  # 3 backticks, followed by at least one non whitespace, non backtick character, followed by (less than 3 backticks, or at least one non backtick character) at least once, followed by exactly 3 backticks
    | (`{2})(?![\s`])(?:[^`]+(?=`)|(?!`{2})`+(?!`))+(`{2})(?!`)  # 2 backticks, followed by at least one non whitespace, non backtick character, followed by (less than 2 backticks, or at least one non backtick character) at least once, followed by exactly 2 backticks
    | (`{1})(?![\s`])(?:[^`]+(?=`)|(?!`{1})`+(?!`))+(`{1})(?!`)  # 1 backtick,  followed by at least one non whitespace, non backtick character, followed by (                          at least one non backtick character) at least once, followed by exactly 1 backtick
    )

  block_quote: (?:[ ]{,3}(>)[ ]?)                     # between 0 and 3 spaces, followed by a greater than sign, (followed by any character or the end of the line = "only care about optional space!")

  first_list_item: (?:[ ]{,3}(?:1[.)]|[*+-])\s)       # between 0 and 3 spaces, followed by either: at least one integer and a full stop or a parenthesis, or (a star, plus or dash), followed by whitespace
  list_item: (?:[ ]{,3}(?:\d{1,9}[.)]|[*+-])\s)       # between 0 and 3 spaces, followed by either: at least one integer and a full stop or a parenthesis, or (a star, plus or dash), followed by whitespace


  table_cell: |-
    (?x:
      # Pipes inside other inline spans (such as emphasis, code, etc.) will not break a cell,
      # emphasis in table cells can't span multiple lines
      (?:
        {{balance_square_brackets_pipes_and_emphasis}}
      | {{balanced_emphasis}}
      )+  # at least one character
    )

  table_first_row: |-
    (?x:
      # at least 2 non-escaped pipe chars on the line
      (?:{{table_cell}}?\|){2}

      # something other than whitespace followed by a pipe char or hyphen,
      # followed by something other than whitespace and the end of the line
    | (?! \s*\-\s+ | \s+\|){{table_cell}}\|(?!\s+$)
    )


  bold_asterisk_begin: |-
    (?x:
         \*{2} {{no_space_nor_punct}}
    | \B \*{2} {{no_space_but_punct}}
    )

  italic_asterisk_begin: |-
    (?x:
         \* {{no_space_nor_punct}}
    | \B \* {{no_space_but_punct}}
    )


# literal_block: |
#   This entire block of text will be the value of the 'literal_block' key, with line breaks being preserved.
#   The literal continues until de-dented, and the leading indentation is stripped.
#       Any lines that are 'more-indented' keep the rest of their indentation - these lines will be indented by 4 spaces.
# folded_style: >
#   This entire block of text will be the value of 'folded_style', but this   time, all newlines will be replaced with a single space.
#   Blank lines, like above, are converted to a newline character.
#       'More-indented' lines keep their newlines, too - this text will appear over two lines.
# literal_strip: |-
#   This entire block of text will be the value of the 'literal_block' key, with trailing blank line being stripped.
# block_strip: >-
#   This entire block of text will be the value of 'folded_style', but this time, all newlines will be replaced with a single space and trailing blank line being stripped.
# literal_keep: |+
#   This entire block of text will be the value of the 'literal_block' key, with trailing blank line being kept.
# block_keep: >+
#   This entire block of text will be the value of 'folded_style', but this time, all newlines will be replaced with a single space and trailing blank line being kept.


contexts:

  main:
    # - include: block-quotes
    # - include: list-blocks
    # - include: tables
    - include: atx-heading

    # test stuff
    - match: 'ZZZZ'
      scope: invalid

    - match: |-
        (?x:
            \s*                        # Leading whitespace
            (\[)(\^[^]]*)(\])(:)       # Reference name
            [ \t]*                     # Optional whitespace
        )
      captures:
        1: punctuation.definition.constant.begin.markdown
        2: entity.name.reference.link.markdown
        3: punctuation.definition.constant.end.markdown
        4: punctuation.separator.key-value.markdown


    # - match: \b(\*[^*]+\*)\b
    - match: (^|\s)(\*[^*]+\*)(^|\s)
      captures:
        2: markup.bold

    - match: (^|\s)(/[^/]+/)($|\s)
      captures:
        2: markup.italic

    # - match: \b(_[^_]+_)\b
    - match: (^|\s)(_[^_]+_)(^|\s)
      captures:
        2: markup.underline

    # - match: (^|\s)\+[^\+]+\+(^|\s)
    - match: (^|\s)(~[^~]+~)(^|\s)
    # - match: \b(~[^~]+~)\b
      captures:
        2: markup.strikethrough
      # scope: markup.strikethrough

    # - match: (^|\s)~[^~]+~(^|\s)
    #   scope: notr.code

    # - match: (^|\s)=[^=]+=(^|\s)
    #   scope: notr.verbatim


  #################### heading - from markdown syntax - ok? ###########################################
  atx-heading:
    # https://spec.commonmark.org/0.30/#atx-headings
    # Consume spaces and tabs after opening hashes so entity.name starts with first non-whitespace character.

    
    - match: '^# +(.+)'
      scope: markup.heading.1.notr
      captures:
        1: markup.heading.label.1.notr
    
    - match: '^## +(.+)'
      scope: markup.heading.2.notr
      captures:
        1: markup.heading.label.2.notr

    - match: '^### +(.+)'
      scope: markup.heading.3.notr
      captures:
        1: markup.heading.label.3.notr

    - match: '^#### +(.+)'
      scope: markup.heading.4.notr
      captures:
        1: markup.heading.label.4.notr

    - match: '^##### +(.+)'
      scope: markup.heading.5.notr
      captures:
        1: markup.heading.label.5.notr



    # - match: '^# +($)'
    #   captures:
    #     1: punctuation.definition.heading.begin.notr
    #   push: atx-heading1-content

    # - match: '^(#{2}){{atx_heading_space}}'
    #   captures:
    #     1: punctuation.definition.heading.begin.notr
    #   push: atx-heading2-content

    # - match: '^(#{3}){{atx_heading_space}}'
    #   captures:
    #     1: punctuation.definition.heading.begin.notr
    #   push: atx-heading3-content

    # - match: '^(#{4}){{atx_heading_space}}'
    #   captures:
    #     1: punctuation.definition.heading.begin.notr
    #   push: atx-heading4-content

    # - match: '^(#{5}){{atx_heading_space}}'
    #   captures:
    #     1: punctuation.definition.heading.begin.notr
    #   push: atx-heading5-content

    # - match: '^(#{6}){{atx_heading_space}}'
    #   captures:
    #     1: punctuation.definition.heading.begin.notr
    #   push: atx-heading6-content

  # atx-heading1-content:
  #   - meta_scope: markup.heading.1.notr
  #   - meta_content_scope: entity.name.section.notr
  #   - include: atx-heading-content

  # atx-heading2-content:
  #   - meta_scope: markup.heading.2.notr
  #   - meta_content_scope: entity.name.section.notr
  #   - include: atx-heading-content

  # atx-heading3-content:
  #   - meta_scope: markup.heading.3.notr
  #   - meta_content_scope: entity.name.section.notr
  #   - include: atx-heading-content

  # atx-heading4-content:
  #   - meta_scope: markup.heading.4.notr
  #   - meta_content_scope: entity.name.section.notr
  #   - include: atx-heading-content

  # atx-heading5-content:
  #   - meta_scope: markup.heading.5.notr
  #   - meta_content_scope: entity.name.section.notr
  #   - include: atx-heading-content

  # atx-heading6-content:
  #   - meta_scope: markup.heading.6.notr
  #   - meta_content_scope: entity.name.section.notr
  #   - include: atx-heading-content

  # atx-heading-content:
  #   - match: '{{atx_heading_end}}'
  #     captures:
  #       1: punctuation.definition.heading.end.notr
  #       2: meta.whitespace.newline.notr
  #     pop: true




  #################### link - from markdown syntax - ok? ###########################################
  autolink-inet:
    - match: (<)((?:https?|ftp)://.*?)(>)
      scope: meta.link.inet.notr
      captures:
        1: punctuation.definition.link.begin.notr
        2: markup.underline.link.notr
        3: punctuation.definition.link.end.notr

    - match: (((https|http|ftp)://)|www\.)[\w-]+(\.[\w-]+)+
      scope: markup.underline.link.notr-gfm
      push: # After a valid domain, zero or more non-space non-< characters may follow
        - match: (?=[?!.,:*_~]*(?:[\s<]|$)) # Trailing punctuation (specifically, ?, !, ., ,, :, *, _, and ~) will not be considered part of the autolink, though they may be included in the interior of the link
          pop: true
        - match: (?={{html_entity}}[?!.,:*_~]*[\s<]) # If an autolink ends in a semicolon (;), we check to see if it appears to resemble an entity reference; if the preceding text is & followed by one or more alphanumeric characters. If so, it is excluded from the autolink
          pop: true
        - match: \( # When an autolink ends in ), we scan the entire autolink for the total number of parentheses. If there is a greater number of closing parentheses than opening ones, we don’t consider the last character part of the autolink, in order to facilitate including an autolink inside a parenthesis
          push:
            - meta_scope: markup.underline.link.notr-gfm
            - match: (?=[?!.,:*_~]*[\s<])
              pop: true
            - match: \)
              pop: true
        - match: (?=\)[?!.,:*_~]*[\s<])
          pop: true
        - match: '[^?!.,:*_~\s<&()]+|\S'
          scope: markup.underline.link.notr-gfm


  #################### list - from markdown syntax - not ###########################################

    # - match: ^(DocId)(\s+(\d\d\d|permanent|temp|seeother|gone))?\s+(.+?)\s+((.+?)($|\s))?
    #   captures:
    #     1: keyword.core.markdown
    #     2: entity.status.markdown
    #     3: string.path.markdown
    #     5: string.path.markdown


    # - match: ^([ ]{0,3})([*+-])( (\[[ xX]\]))?(?=\s)
    #   captures:
    #     1: markup.list.unnumbered.markdown
    #     2: markup.list.unnumbered.bullet.markdown punctuation.definition.list_item.markdown
    #     3: markup.list.unnumbered.markdown
    #     4: constant.language.checkbox.markdown-gfm
    #   push:
    #     - meta_content_scope: markup.list.unnumbered.markdown
    #     - match: ^(?=\S)
    #       pop: true
    #     - include: list-paragraph

    # - match: ^([ ]{0,3})(\d+([.)]))(?=\s)
    #   captures:
    #     1: markup.list.numbered.markdown
    #     2: markup.list.numbered.bullet.markdown
    #     3: punctuation.definition.list_item.markdown
    #   push:
    #     - meta_content_scope: markup.list.numbered.markdown
    #     - match: ^(?=\S)
    #       pop: true
    #     - include: list-paragraph


